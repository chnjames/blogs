import{_ as e,p as o,q as d,Y as c}from"./framework-aa5c4115.js";const a={},r=c('<h1 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h1><h2 id="谈谈你对mvvm的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对mvvm的理解" aria-hidden="true">#</a> 谈谈你对MVVM的理解</h2><p><code>MVVM</code>是<code>Model-View-ViewModel</code>的缩写，它是一种基于前端开发的架构模式。由<code>Model</code>、<code>View</code>、<code>ViewModel</code>三部分组成。其核心的提供对<code>View</code>和<code>ViewModel</code>的双向数据绑定，这使得<code>ViewModel</code>的状态改变可以自动传递给<code>View</code>，即所谓的数据双向绑定。<code>ViewModel</code>是核心，负责连接<code>View</code>和<code>Model</code>，保证视图和数据一致性，这种轻量级的架构让前端开发更加高效、便捷。</p><ul><li><code>Model</code>代表数据模型，也可以在<code>Model</code>中定义数据修改和业务逻辑；</li><li><code>View</code>代表 UI 组件，他负责将数据模型转化成 UI 展现出来；</li><li><code>ViewModel</code>是一个同步<code>View</code>和<code>Model</code>的对象。</li></ul><p><code>Vue.js</code>是<code>MVVM</code>架构的最佳实践，但并没有完全遵循<code>MVVM</code>，专注于<code>MVVM</code>中的<code>ViewModel</code>，不仅做到了数据双向绑定，而且还是较轻量级的JS库。</p><h2 id="vue双向绑定原理" tabindex="-1"><a class="header-anchor" href="#vue双向绑定原理" aria-hidden="true">#</a> Vue双向绑定原理</h2><p>Vue数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。</p><p><img src="https://raw.githubusercontent.com/chnjames/cloudImg/main/blog/202206221421927.png" alt="image-20220622142138245"></p><p><code>Observer</code>：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用<code>Object.defineProperty</code>的<code>getter</code>和<code>setter</code>来实现。</p><p><code>Compile</code>：指令解析器，他的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</p><p><code>Watcher</code>：订阅者，作为连接<code>Observer</code>和<code>Compile</code>的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。</p><p><code>Dep</code>：消息订阅器，内部维护了一个数组，用来收集订阅者（<code>Watcher</code>），数据变动触发<code>notify</code>函数，再调用订阅者的<code>update</code>方法。</p><p>从图中可以看出，**当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面 Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter / setter，实现数据变化监听功能；另一方面，Vue 的指令编译器 Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅 Watcher 来更新视图，此时 Watcher 会将自己添加到消息订阅器中（Dep），初始化完毕。 **</p><p><strong>当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用 Dep.notify()，Dep开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。</strong></p><h2 id="package-json与package-lock-json的关系" tabindex="-1"><a class="header-anchor" href="#package-json与package-lock-json的关系" aria-hidden="true">#</a> <code>package.json</code>与<code>package-lock.json</code>的关系</h2><blockquote><p><code>pageage.json</code>用来描述项目及项目所依赖的模块信息。</p></blockquote><h3 id="语义版本控制" tabindex="-1"><a class="header-anchor" href="#语义版本控制" aria-hidden="true">#</a> 语义版本控制</h3><p>版本号：</p><p>组成：<code>major.minor.patch</code>，即主版本号.次版本号.修补版本号。</p><h3 id="安装依赖包的版本" tabindex="-1"><a class="header-anchor" href="#安装依赖包的版本" aria-hidden="true">#</a> 安装依赖包的版本</h3><p>安装依赖包的时候，版本号前面都会带有<code>^</code>或<code>~</code>的符号：</p><p><code>~</code>会匹配最近的小版本依赖包，比如<code>~1.2.3</code>会匹配所有<code>1.2.x</code>版本，但是不包括<code>1.3.0</code></p><p><code>^</code>会匹配最新的大版本依赖包，比如<code>^1.2.3</code>会匹配所有<code>1.x.x</code>的包，包括<code>1.3.0</code>，但是不包括<code>2.0.0</code></p><p><code>*</code>安装最新版本的依赖包，比如<code>*1.2.3</code>会匹配<code>x.x.x</code></p>',24),t=[r];function i(p,n){return o(),d("div",null,t)}const l=e(a,[["render",i],["__file","Vue.html.vue"]]);export{l as default};
